Fuzz方法
========================================================

简介
--------------------------------------------------------
Fuzz又称模糊测试，是一种侧重于发现软件安全漏洞的方法。典型的Fuzz测试过程是通过自动的或半自动的方法，反复驱动目标软件运行，并为其提供特别构造的输入数据，同时监控软件运行的异常，进而根据异常结果及输入数据查找软件的安全漏洞。谷歌、微软、思科等公司都使用模糊测试作为软件安全开发流程的一部分。

白盒Fuzz
--------------------------------------------------------
白盒Fuzz会先对应用进行分析，以确保其创建的输入能在应用程序中发现崩溃。 但是一个应用程序一般有有许多分支，然后形成许多可能的执行流。

不过如果有了很大的测试空间，就有可能创建几乎无限的输入来遍历所有的执行流。一般白盒Fuzz会试图创造在更少的输入的同时来尽量覆盖更多的路径。目前也有一些研究取得了成果，比如CRAX[1-2]就用符号执行的方式完成了一个白盒浏览器漏洞Fuzz工具。

但是由于执行流程过多和复杂的约束，白盒Fuzz在应用程序中可能并不精确。 此外，白盒Fuzz分析应用程序需要比较多的时间，所以浏览器Fuzz一般仍以黑盒Fuzz为主。

符号执行
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
符号执行是白盒Fuzz的一个常用技术。其关键思想就是，把输入变为符号值，那么程序计算的输出值就是一个符号输入值的函数。这个符号化的过程在文章[1-9]中已有简要阐述，简而言之，就是一个程序执行的路径通常是true和false条件的序列，这些条件是在分支语句处产生的。

符号执行要解决的问题主要是路径选择、约束求解、内存建模、处理并发这几个方面。

黑盒Fuzz
--------------------------------------------------------
黑盒Fuzz是一个有效和找到漏洞的简单方法，和白盒不同的是，黑盒Fuzz将直接产生输入然后尝试找到结果，而黑盒Fuzz又可以更细分为Genertion-Based Fuzz和Mutation-Based Fuzz或者混合型的Hybrid Fuzz。 

Mutation-Based Fuzz
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
在Mutation-Based Fuzz中，一般会提供一个到多个有效的样本。
简单的Fuzz会对这些样本进行字节级或者字符级别的替换、删除、增加、重复。相对来说，这种Fuzz方式比较好实现，而且几乎不需要任何的先验知识，只要有一个或几个构造好的样本即可。但是相对来说，这种Fuzz方式也更依赖于给定的样本，如果样本触发的代码覆盖率不高，那么这种方式的覆盖率一般也不会高。

Genertion-Based Fuzz
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Genertion-Based Fuzz通常使用的方法有基于随机字符的生成、基于语法结构的生成等。相对Mutation-Based Fuzz，直接生成样本的方式覆盖率会更高。但是相对的，这种方式也需要更多的种子样本，对样本的依赖性也更强。

Hybrid Fuzz
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
考虑到Genertion-Based和Mutation-Based的优缺点，那么另一种方式就是结合两种模式共同进行Fuzz，生成随机样本之后再进行相应的变换，以获得更好的Fuzz效率。

灰盒Fuzz
--------------------------------------------------------
结合黑盒和白盒两种方式进行Fuzz。既使用黑盒Fuzz的方式，也使用白盒Fuzz进行一定的符号执行。比单纯的白盒Fuzz更轻量级，比黑盒Fuzz更有效率。
